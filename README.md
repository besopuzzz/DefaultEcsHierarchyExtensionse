# Неофициальный проект расширения иерархии в DefaultEcs
Проект дает возможность выстраивать иерархию сущностей по-умолчанию и по компонент-ключу.
Используйте проект как идею для создания своей иерархии (уверен, профессионалы сделают лучше) или проект.

# Как использовать:
1. Создаем мир и сущности.
2. Используем методы расширения SetParent статического класса EntityExtensions, для создания базовой иерархии.
3. Получаем ссылку на дерево, используя метод Trees.GetRoot(world) для получения базовой иерархии, либо Trees.GetOrCreate<TKey>(world) для получения иерархии по компонент-ключу.
4. Используем методы дерева для работы с иерархии: события, связанные с изменениями в иерархии, получение дочерних сущностей или для получения ссылки на родителя.
5. По окончанию использования очищаем дерево Dispose(). Дерево очистится вместе с маркер-компонентами, если ссылок на дерево больше нет.

# Приемущество
- Зависимость только от проекта DefaultEcs.
- Выстраивание иерархии по ключу начинается после создания любого дерева.
- Дерево связывает сущности через маркер HierarchyKey<TKey>, где TKey - компонент-ключ. Тип HierarchyKey<TKey> является публичным и вы в любой момент можете узнать ссылку на родительский TKey.
- Если дерево создано с помощью Trees.GetOrCreate<T, TKey>, где T - это обычный компонент, для которого нужна связка с TKey, а TKey - компонент-ключ, то все сущности с T компонентом будут иметь связь с родительским TKey с помощью маркера HierarchyKey<TKey>. Это дает возможность комбинировать типами в иерархии. Например, есть компонент Element, а есть ключ GroupElement. Все сущности с компонентом Element будут иметь маркер (HierarchyKey<GroupElement>) с ссылкой на ближайшую сущность с компонентом GroupElement. Так же отличным примером является Холст(TKey) и спрайты (T).
- Прекрасно работает с MultyMapSystem, так как сущности имеет один и тот же маркер (HierarchyKey<TKey>) и будут прекрасно группироваться. Используйте это преимущество для работы с иерархией в своих системах. Например, есть система AEntityMultiMapSystem<GameTime, HierarchyKey<TKey>>. Переопределенный метод PreUpdate(GameTime state, HierarchyKey<TKey> key) даст возможность понять, для какого родителя начинается обновление дочерних сущностей. А метод void Update(GameTime state, in HierarchyKey<TKey> key, in Entity entity) будет вызван для каждой дочерней сущности, где у сущности гарантировано будет компонент либо T, либо TKey (зависит от типа созданного дерева).
- Вызов Dispose() у сущности так же вызывает Dispose() у дочерних сущностей только после создания любого дерева. До вызова Trees.GetRoot или Trees.GetOrCreate дочерние компоненты не будут освобождены.
